=== BRIDGE PIER GEOMETRY TOOL - COMPLETE CODE PACKAGE ===
Generated: Sun Jul 27 09:32:32 PM UTC 2025

This is a comprehensive 3D bridge pier geometry design tool for civil engineering applications.
Features: Interactive 3D visualization, curved/straight alignments, continuous/simple spans, haunch geometry, quantity takeoffs.

================================================================================================
MAIN COMPONENT: client/src/components/BridgePierGeometryTool.tsx
================================================================================================

import React, { useState, useMemo, useRef, useEffect } from 'react';
import * as THREE from 'three';
import { Canvas } from '@react-three/fiber';
import { OrbitControls, OrthographicCamera, PerspectiveCamera, Edges } from '@react-three/drei';

// Bridge Pier Geometry Tool Component
export default function BridgePierGeometryTool() {
  // --- State (inches) ---
  const [rowsL, setRowsL] = useState(3);
  const [rowsW, setRowsW] = useState(6);
  const [spacing, setSpacing] = useState(144);
  const [edgeDist, setEdgeDist] = useState(48);
  const [pileDia, setPileDia] = useState(48);
  const [capThk, setCapThk] = useState(144);
  const [embed, setEmbed] = useState(12);
  const [pileLen, setPileLen] = useState(1200);

  // Columns
  const [colCount, setColCount] = useState(2);
  const [colSpacing, setColSpacing] = useState(432);
  const [colShape, setColShape] = useState('rectangular');
  const [colW, setColW] = useState(168);
  const [colD, setColD] = useState(132);
  const [colH, setColH] = useState(2038);

  // Pier cap
  const [pierW, setPierW] = useState(1098);
  const [pierInset, setPierInset] = useState(237);
  const [pierL, setPierL] = useState(144);
  const [pierThk, setPierThk] = useState(144);
  const [pierTipThk, setPierTipThk] = useState(96);

  // Built-up Plate Girder (inches)
  const [bfTop, setBfTop] = useState(36);   // Top flange width
  const [tfTop, setTfTop] = useState(2);    // Top flange thickness
  const [bfBot, setBfBot] = useState(36);   // Bottom flange width
  const [tfBot, setTfBot] = useState(3);    // Bottom flange thickness
  const [webH, setWebH] = useState(144);    // Web height
  const [webT, setWebT] = useState(1);      // Web thickness

  // Deck Geometry (inches)
  const [deckThk, setDeckThk] = useState(9);
  const [deckOverhang, setDeckOverhang] = useState(42);
  
  // Haunch Geometry (inches)
  const [haunchThk, setHaunchThk] = useState(6); // Minimum haunch thickness at girder centerline

  // Girder configuration
  const [girderCount, setGirderCount] = useState(8);
  const [girderSpacing, setGirderSpacing] = useState(144);
  const [continuousGirders, setContinuousGirders] = useState(true);

  // derive girder positions across deck width
  const girderPos = useMemo(() => {
    const arr = [];
    const n = Math.max(1, girderCount);
    const total = girderSpacing * (n - 1);
    for (let i = 0; i < n; i++) arr.push(-total/2 + i * girderSpacing);
    return arr;
  }, [girderCount, girderSpacing]);

  const [spanCount, setSpanCount] = useState(2);
  const [spanLength, setSpanLength] = useState(1800);
  const [roadSlope, setRoadSlope] = useState(0.000);
  const [usePerspective, setUsePerspective] = useState(true);
  const [wireframe, setWireframe] = useState(false);
  const [edgesVisible, setEdgesVisible] = useState(false);
  const [fitToScreen, setFitToScreen] = useState(false);

  // Curve settings
  const [useCurve, setUseCurve] = useState(false);
  const [curveRadius, setCurveRadius] = useState(10000);
  const [curveStartAngle, setCurveStartAngle] = useState(0);
  const [curveDirection, setCurveDirection] = useState('left');

  // --- Derived Data ---
  const { capW, capL, pilePos } = useMemo(() => {
    const w = 2 * edgeDist + (rowsW - 1) * spacing + rowsW * pileDia;
    const l = 2 * edgeDist + (rowsL - 1) * spacing + rowsL * pileDia;
    const pos = [];
    for (let i = 0; i < rowsL; i++) {
      for (let j = 0; j < rowsW; j++) {
        pos.push([
          -w/2 + edgeDist + pileDia/2 + j*(spacing+pileDia),
          -l/2 + edgeDist + pileDia/2 + i*(spacing+pileDia)
        ]);
      }
    }
    return { capW: w, capL: l, pilePos: pos };
  }, [rowsL, rowsW, spacing, edgeDist, pileDia]);

  const pileTopY = -capThk + embed;
  const pileCenterY = pileTopY - pileLen/2;
  const baseColH = colH - pierThk;

  const colsPos = useMemo(() => {
    const arr = [];
    const n = Math.max(1, Math.min(colCount, 4));
    const gap = colSpacing*(n-1);
    for (let i = 0; i < n; i++) arr.push([-gap/2 + i*colSpacing, 0]);
    return arr;
  }, [colCount, colSpacing]);

  const pierInfos = useMemo(() => {
    const infos = [];
    const total = spanCount * spanLength;
    if (useCurve && curveRadius > 0) {
      const sign = curveDirection === 'left' ? 1 : -1;
      const startRad = THREE.MathUtils.degToRad(curveStartAngle);
      const delta = spanLength/curveRadius * sign;
      for (let i = 0; i <= spanCount; i++) {
        const theta = startRad + i*delta;
        const x = curveRadius*Math.cos(theta) - curveRadius*Math.cos(startRad);
        const z = curveRadius*Math.sin(theta) - curveRadius*Math.sin(startRad);
        const elev = i*spanLength*roadSlope;
        const tangent = theta + sign*Math.PI/2;
        infos.push({ x, z, elev, rotY: -tangent + Math.PI/2 });
      }
    } else {
      const start = -total/2;
      for (let i = 0; i <= spanCount; i++) {
        infos.push({ x:0, z: start + i*spanLength, elev: i*spanLength*roadSlope, rotY: 0 });
      }
    }
    return infos;
  }, [useCurve, curveRadius, curveStartAngle, curveDirection, spanCount, spanLength, roadSlope]);

  const pierShape = useMemo(() => {
    const half = pierW/2;
    const overhang = Math.min(pierInset, half);
    const yTop = pierThk/2;
    const yBot = -pierThk/2;
    const yTip = yTop - pierTipThk;
    const shape = new THREE.Shape();
    shape.moveTo(-half, yTop);
    shape.lineTo(half, yTop);
    shape.lineTo(half, yTip);
    shape.lineTo(half-overhang, yBot);
    shape.lineTo(-half+overhang, yBot);
    shape.lineTo(-half, yTip);
    shape.closePath();
    return shape;
  }, [pierW, pierThk, pierInset, pierTipThk]);

  const pileCapVol = capW/12 * capL/12 * capThk/12;
  const pierCapVol = pierW/12 * pierL/12 * pierThk/12;

  const maxDim = useMemo(() => Math.max(capW, capL, pileLen, baseColH + spanCount*spanLength*roadSlope + pierThk, pierW, spanCount*spanLength),
    [capW, capL, pileLen, baseColH, spanCount, spanLength, roadSlope, pierW]
  );
  const camDist = maxDim*2;

  // Function to create curved geometry points along the bridge alignment
  const createCurvedPoints = useMemo(() => {
    return (startInfo: any, endInfo: any, segments = 20) => {
      const points = [];
      if (useCurve && curveRadius > 0) {
        const sign = curveDirection === 'left' ? 1 : -1;
        const startRad = THREE.MathUtils.degToRad(curveStartAngle);
        
        // Find the position of start and end along the total bridge alignment
        let startDistance = 0;
        let endDistance = 0;
        
        // Calculate cumulative distances to find span positions
        let foundStart = false, foundEnd = false;
        for (let i = 0; i < pierInfos.length; i++) {
          if (pierInfos[i] === startInfo) {
            startDistance = i * spanLength;
            foundStart = true;
          }
          if (pierInfos[i] === endInfo) {
            endDistance = i * spanLength;
            foundEnd = true;
          }
        }
        
        // If we can't find the pier infos, fall back to straight geometry
        if (!foundStart || !foundEnd) {
          console.warn('Could not find pier infos in array, falling back to straight geometry');
        } else {
          // Generate points along the global curve between start and end positions
          for (let i = 0; i <= segments; i++) {
            const t = i / segments;
            const currentDistance = startDistance + t * (endDistance - startDistance);
            const theta = startRad + (currentDistance / curveRadius) * sign;
            
            const x = curveRadius * Math.cos(theta) - curveRadius * Math.cos(startRad);
            const z = curveRadius * Math.sin(theta) - curveRadius * Math.sin(startRad);
            const elev = startInfo.elev + t * (endInfo.elev - startInfo.elev);
            
            points.push(new THREE.Vector3(x, elev, z));
          }
        }
      }
      
      // If no curved points were generated or curve is disabled, use straight geometry
      if (points.length === 0) {
        for (let i = 0; i <= segments; i++) {
          const t = i / segments;
          const x = startInfo.x + t * (endInfo.x - startInfo.x);
          const z = startInfo.z + t * (endInfo.z - startInfo.z);
          const elev = startInfo.elev + t * (endInfo.elev - startInfo.elev);
          points.push(new THREE.Vector3(x, elev, z));
        }
      }
      return points;
    };
  }, [useCurve, curveRadius, curveDirection, curveStartAngle, pierInfos, spanLength]);

  const controlsRef = useRef<any>();
  useEffect(() => { 
    if (fitToScreen && controlsRef.current) { 
      controlsRef.current.reset(); 
      setFitToScreen(false);
    } 
  }, [fitToScreen]);

  const handlePrint = () => window.print();
  const handleDXF = () => { 
    // DXF export functionality would be implemented here
    alert('DXF export functionality would be implemented with a CAD library'); 
  };

  return (
    <div className="flex h-screen font-sans">
      <aside className="w-80 p-4 bg-gray-100 shadow-lg overflow-auto space-y-4">
        <div className="flex justify-between items-center">
          <h2 className="text-2xl font-bold">Bridge Pier Tool</h2>
          <div className="space-x-2">
            <button onClick={handlePrint} className="px-3 py-1 bg-blue-600 text-white rounded hover:bg-blue-700">Print</button>
            <button onClick={handleDXF} className="px-3 py-1 bg-green-600 text-white rounded hover:bg-green-700">DXF</button>
          </div>
        </div>

        {/* Alignment */}
        <details open className="bg-white border rounded">
          <summary className="px-3 py-1 font-medium cursor-pointer">Alignment</summary>
          <div className="p-3 grid grid-cols-2 gap-3 text-sm">
            <label className="flex items-center">
              <input type="checkbox" checked={useCurve} onChange={()=>setUseCurve(!useCurve)} className="mr-1"/>
              Use Curve
            </label>
            <div></div>
            {useCurve && (
              <>
                <label>
                  Radius
                  <input type="number" value={curveRadius} onChange={e=>setCurveRadius(+e.target.value)} className="w-full p-1 border rounded"/>
                </label>
                <label>
                  Start Angle
                  <input type="number" value={curveStartAngle} onChange={e=>setCurveStartAngle(+e.target.value)} className="w-full p-1 border rounded"/>
                </label>
                <label>
                  Direction
                  <select value={curveDirection} onChange={e=>setCurveDirection(e.target.value)} className="w-full p-1 border rounded">
                    <option value="left">Left</option>
                    <option value="right">Right</option>
                  </select>
                </label>
              </>
            )}
          </div>
        </details>

        {/* Pile Grid */}
        <details className="bg-white border rounded">
          <summary className="px-3 py-1 font-medium cursor-pointer">Pile Grid</summary>
          <div className="p-3 grid grid-cols-2 gap-3 text-sm">
            <label>Rows L<input type="number" value={rowsL} onChange={e=>setRowsL(+e.target.value)} className="w-full p-1 border rounded"/></label>
            <label>Rows W<input type="number" value={rowsW} onChange={e=>setRowsW(+e.target.value)} className="w-full p-1 border rounded"/></label>
            <label>Spacing<input type="number" value={spacing} onChange={e=>setSpacing(+e.target.value)} className="w-full p-1 border rounded"/></label>
            <label>Edge Dist<input type="number" value={edgeDist} onChange={e=>setEdgeDist(+e.target.value)} className="w-full p-1 border rounded"/></label>
            <label>Dia<input type="number" value={pileDia} onChange={e=>setPileDia(+e.target.value)} className="w-full p-1 border rounded"/></label>
          </div>
        </details>

        {/* Pile Cap */}
        <details className="bg-white border rounded">
          <summary className="px-3 py-1 font-medium cursor-pointer">Pile Cap</summary>
          <div className="p-3 grid grid-cols-2 gap-3 text-sm">
            <label>Depth<input type="number" value={capThk} onChange={e=>setCapThk(+e.target.value)} className="w-full p-1 border rounded"/></label>
            <label>Embed<input type="number" value={embed} onChange={e=>setEmbed(+e.target.value)} className="w-full p-1 border rounded"/></label>
            <label>Length<input type="number" value={pileLen} onChange={e=>setPileLen(+e.target.value)} className="w-full p-1 border rounded"/></label>
          </div>
        </details>

        {/* Columns */}
        <details className="bg-white border rounded">
          <summary className="px-3 py-1 font-medium cursor-pointer">Columns</summary>
          <div className="p-3 grid grid-cols-3 gap-3 text-sm">
            <label>Count<input type="number" min={1} max={4} value={colCount} onChange={e=>setColCount(+e.target.value)} className="w-full p-1 border rounded"/></label>
            <label>Spacing<input type="number" value={colSpacing} onChange={e=>setColSpacing(+e.target.value)} className="w-full p-1 border rounded"/></label>
            <label>Shape<select value={colShape} onChange={e=>setColShape(e.target.value)} className="w-full p-1 border rounded"><option value="rectangular">Rectangular</option><option value="circular">Circular</option></select></label>
            <label>W<input type="number" value={colW} onChange={e=>setColW(+e.target.value)} className="w-full p-1 border rounded"/></label>
            {colShape==='rectangular' && <label>D<input type="number" value={colD} onChange={e=>setColD(+e.target.value)} className="w-full p-1 border rounded"/></label>}
            <label>H<input type="number" value={colH} onChange={e=>setColH(+e.target.value)} className="w-full p-1 border rounded"/></label>
          </div>
        </details>

        {/* Pier Cap */}
        <details className="bg-white border rounded">
          <summary className="px-3 py-1 font-medium cursor-pointer">Pier Cap</summary>
          <div className="p-3 grid grid-cols-3 gap-3 text-sm">
            <label>Width<input type="number" value={pierW} onChange={e=>setPierW(+e.target.value)} className="w-full p-1 border rounded"/></label>
            <label>Overhang<input type="number" value={pierInset} onChange={e=>setPierInset(+e.target.value)} className="w-full p-1 border rounded"/></label>
            <label>Tip Thk<input type="number" value={pierTipThk} onChange={e=>setPierTipThk(+e.target.value)} className="w-full p-1 border rounded"/></label>
            <label>Length<input type="number" value={pierL} onChange={e=>setPierL(+e.target.value)} className="w-full p-1 border rounded"/></label>
            <label>Depth<input type="number" value={pierThk} onChange={e=>setPierThk(+e.target.value)} className="w-full p-1 border rounded"/></label>
          </div>
        </details>

        {/* Spans & Slope */}
        <details className="bg-white border rounded">
          <summary className="px-3 py-1 font-medium cursor-pointer">Spans & Slope</summary>
          <div className="p-3 grid grid-cols-2 gap-3 text-sm">
            <label># Spans<input type="number" min={1} value={spanCount} onChange={e=>setSpanCount(+e.target.value)} className="w-full p-1 border rounded"/></label>
            <label>Span Len<input type="number" value={spanLength} onChange={e=>setSpanLength(+e.target.value)} className="w-full p-1 border rounded"/></label>
            <label>Road Slope<input type="number" step="0.001" value={roadSlope} onChange={e=>setRoadSlope(+e.target.value)} className="w-full p-1 border rounded"/></label>
          </div>
        </details>

        {/* Superstructure */}
        <details className="bg-white border rounded">
          <summary className="px-3 py-1 font-medium cursor-pointer">Superstructure</summary>
          <div className="p-3 grid grid-cols-2 gap-3 text-sm">
            <label>Top Flange Width<input type="number" value={bfTop} onChange={e=>setBfTop(+e.target.value)} className="w-full p-1 border rounded"/></label>
            <label>Top Flange Thk<input type="number" value={tfTop} onChange={e=>setTfTop(+e.target.value)} className="w-full p-1 border rounded"/></label>
            <label>Bottom Flange Width<input type="number" value={bfBot} onChange={e=>setBfBot(+e.target.value)} className="w-full p-1 border rounded"/></label>
            <label>Bottom Flange Thk<input type="number" value={tfBot} onChange={e=>setTfBot(+e.target.value)} className="w-full p-1 border rounded"/></label>
            <label>Web Height<input type="number" value={webH} onChange={e=>setWebH(+e.target.value)} className="w-full p-1 border rounded"/></label>
            <label>Web Thk<input type="number" value={webT} onChange={e=>setWebT(+e.target.value)} className="w-full p-1 border rounded"/></label>
            <label>Deck Thk<input type="number" value={deckThk} onChange={e=>setDeckThk(+e.target.value)} className="w-full p-1 border rounded"/></label>
            <label>Deck Overhang<input type="number" value={deckOverhang} onChange={e=>setDeckOverhang(+e.target.value)} className="w-full p-1 border rounded"/></label>
            <label>Haunch Thk<input type="number" value={haunchThk} onChange={e=>setHaunchThk(+e.target.value)} className="w-full p-1 border rounded"/></label>
            <label>Girder Count<input type="number" value={girderCount} onChange={e => setGirderCount(+e.target.value)} className="w-full p-1 border rounded"/></label>
            <label>Girder Spacing<input type="number" value={girderSpacing} onChange={e => setGirderSpacing(+e.target.value)} className="w-full p-1 border rounded"/></label>
            <label className="flex items-center col-span-2">
              <input type="checkbox" checked={continuousGirders} onChange={()=>setContinuousGirders(!continuousGirders)} className="mr-1"/>
              Continuous Girders Over Piers
            </label>
          </div>
        </details>

        {/* View Options */}
        <details className="bg-white border rounded">
          <summary className="px-3 py-1 font-medium cursor-pointer">View</summary>
          <div className="p-3 space-y-2 text-sm">
            <label className="flex items-center">
              <input type="checkbox" checked={usePerspective} onChange={()=>setUsePerspective(!usePerspective)} className="mr-1"/>
              Perspective
            </label>
            <label className="flex items-center">
              <input type="checkbox" checked={wireframe} onChange={()=>setWireframe(!wireframe)} className="mr-1"/>
              Wireframe
            </label>
            <label className="flex items-center">
              <input type="checkbox" checked={edgesVisible} onChange={()=>setEdgesVisible(!edgesVisible)} className="mr-1"/>
              Solid Edges
            </label>
            <button onClick={()=>setFitToScreen(true)} className="mt-1 px-2 py-1 bg-gray-200 rounded hover:bg-gray-300">Fit Screen</button>
          </div>
        </details>

        {/* Quantities */}
        <details className="bg-white border rounded">
          <summary className="px-3 py-1 font-medium cursor-pointer">Quantities</summary>
          <div className="p-3 text-sm space-y-2">
            {pierInfos.map(({elev},i)=>{
              const np = rowsL*rowsW;
              const tl = np*pileLen;
              const ch = baseColH + elev;
              const cv = (colW/12)*(colShape==='rectangular'?colD/12:Math.PI*(colW/2/12)**2)*(ch/12)*colCount;
              
              // Calculate girder steel quantities per span
              const spanLength = i < pierInfos.length - 1 ? Math.sqrt(
                Math.pow(pierInfos[i+1].x - pierInfos[i].x, 2) + 
                Math.pow(pierInfos[i+1].z - pierInfos[i].z, 2)
              ) : 0;
              
              // Steel quantities per girder in cubic inches
              const webVol = webT * webH * spanLength;
              const topFlangeVol = bfTop * tfTop * spanLength;
              const botFlangeVol = bfBot * tfBot * spanLength;
              const girderSteelVol = (webVol + topFlangeVol + botFlangeVol) * girderCount / 1728; // Convert to ft³
              
              // Deck concrete volume per span
              const deckWidth = girderSpacing * (girderCount - 1) + deckOverhang * 2;
              const deckVol = deckWidth * deckThk * spanLength / 1728; // Convert to ft³
              
              // Haunch concrete volume per span (distributed along girder lines)
              const haunchVol = girderCount * bfTop * haunchThk * spanLength / 1728; // Convert to ft³
              
              return (
                <div key={i} className="border-b pb-1">
                  <div className="font-semibold">Pier {i+1}</div>
                  <div># Piles: {np}</div>
                  <div>Total Pile Len: {tl} in</div>
                  <div>P Cap Vol: {pileCapVol.toFixed(2)} ft³</div>
                  <div>Col Vol: {cv.toFixed(2)} ft³</div>
                  <div>Pier Cap Vol: {pierCapVol.toFixed(2)} ft³</div>
                  {spanLength > 0 && (
                    <>
                      <div>Span Length: {(spanLength/12).toFixed(1)} ft</div>
                      <div>Girder Steel: {girderSteelVol.toFixed(2)} ft³</div>
                      <div>Deck Concrete: {deckVol.toFixed(2)} ft³</div>
                      <div>Haunch Concrete: {haunchVol.toFixed(2)} ft³</div>
                    </>
                  )}
                </div>
              );
            })}
            <div className="mt-2 font-semibold">Overall Totals</div>
            <div>Total Piers: {pierInfos.length}</div>
            <div>Total Piles: {pierInfos.length * rowsL * rowsW}</div>
            <div>Total Pile Length: {((pierInfos.length * rowsL * rowsW * pileLen)/12).toFixed(0)} ft</div>
            <div>Total Pile Cap Vol: {(pierInfos.length * pileCapVol).toFixed(2)} ft³</div>
            <div>Total Column Vol: {(pierInfos.reduce((s,{elev})=>s + (colW/12)*(colShape==='rectangular'?colD/12:Math.PI*(colW/2/12)**2)*((baseColH+elev)/12)*colCount,0)).toFixed(2)} ft³</div>
            <div>Total Pier Cap Vol: {(pierInfos.length * pierCapVol).toFixed(2)} ft³</div>
            
            {/* Superstructure totals */}
            {(() => {
              let totalGirderSteel = 0;
              let totalDeckConcrete = 0;
              let totalHaunchConcrete = 0;
              let totalSpanLength = 0;
              
              for (let i = 0; i < pierInfos.length - 1; i++) {
                const spanDist = Math.sqrt(
                  Math.pow(pierInfos[i+1].x - pierInfos[i].x, 2) + 
                  Math.pow(pierInfos[i+1].z - pierInfos[i].z, 2)
                );
                totalSpanLength += spanDist;
                
                // Steel per span
                const webVol = webT * webH * spanDist;
                const topFlangeVol = bfTop * tfTop * spanDist;
                const botFlangeVol = bfBot * tfBot * spanDist;
                const spanGirderSteel = (webVol + topFlangeVol + botFlangeVol) * girderCount / 1728;
                totalGirderSteel += spanGirderSteel;
                
                // Deck per span
                const deckWidth = girderSpacing * (girderCount - 1) + deckOverhang * 2;
                const spanDeckVol = deckWidth * deckThk * spanDist / 1728;
                totalDeckConcrete += spanDeckVol;
                
                // Haunch per span
                const spanHaunchVol = girderCount * bfTop * haunchThk * spanDist / 1728;
                totalHaunchConcrete += spanHaunchVol;
              }
              
              // If continuous girders, adjust calculation
              if (continuousGirders && pierInfos.length > 1) {
                totalGirderSteel = 0;
                totalDeckConcrete = 0;
                totalHaunchConcrete = 0;
                
                const webVol = webT * webH * totalSpanLength;
                const topFlangeVol = bfTop * tfTop * totalSpanLength;
                const botFlangeVol = bfBot * tfBot * totalSpanLength;
                totalGirderSteel = (webVol + topFlangeVol + botFlangeVol) * girderCount / 1728;
                
                const deckWidth = girderSpacing * (girderCount - 1) + deckOverhang * 2;
                totalDeckConcrete = deckWidth * deckThk * totalSpanLength / 1728;
                totalHaunchConcrete = girderCount * bfTop * haunchThk * totalSpanLength / 1728;
              }
              
              return (
                <>
                  <div className="mt-1 border-t pt-1">
                    <div className="font-semibold">Superstructure</div>
                    <div>Total Bridge Length: {(totalSpanLength/12).toFixed(1)} ft</div>
                    <div>Total Girder Steel: {totalGirderSteel.toFixed(2)} ft³</div>
                    <div>Total Deck Concrete: {totalDeckConcrete.toFixed(2)} ft³</div>
                    <div>Total Haunch Concrete: {totalHaunchConcrete.toFixed(2)} ft³</div>
                    <div>Girder Type: {continuousGirders ? 'Continuous' : 'Simple Span'}</div>
                  </div>
                  <div className="mt-1 border-t pt-1">
                    <div className="font-semibold">Material Summary</div>
                    <div>Concrete: {(pierInfos.length * (pileCapVol + pierCapVol) + pierInfos.reduce((s,{elev})=>s + (colW/12)*(colShape==='rectangular'?colD/12:Math.PI*(colW/2/12)**2)*((baseColH+elev)/12)*colCount,0) + totalDeckConcrete + totalHaunchConcrete).toFixed(2)} ft³</div>
                    <div>Steel: {totalGirderSteel.toFixed(2)} ft³</div>
                    <div>Pile Driving: {((pierInfos.length * rowsL * rowsW * pileLen)/12).toFixed(0)} LF</div>
                  </div>
                </>
              );
            })()}
          </div>
        </details>
      </aside>

      <main className="flex-1 bg-white">
        <Canvas shadows>
          {usePerspective
            ? <PerspectiveCamera makeDefault position={[camDist,camDist,camDist]} fov={50} near={0.1} far={camDist*3} />
            : <OrthographicCamera makeDefault position={[camDist,camDist,camDist]} zoom={0.7} near={0.1} far={camDist*3} />
          }
          <ambientLight intensity={0.6}/>
          <directionalLight position={[camDist,camDist,camDist]} intensity={0.4}/>
          
          {/* Render Piers */}
          {pierInfos.map(({x,z,elev,rotY},idx)=>(
            <group key={idx} position={[x,0,z]} rotation={[0,rotY,0]}>
              {/* Pile Cap */}
              <mesh position={[0,-capThk/2,0]}> 
                <boxGeometry args={[capW,capThk,capL]}/> 
                <meshStandardMaterial wireframe={wireframe} color="lightgray" transparent opacity={0.5} depthWrite={false}/> 
                {edgesVisible && <Edges color="black"/>} 
              </mesh>
              
              {/* Pier Cap */}
              <mesh position={[0, baseColH + elev + pierThk/2, -pierL/2]}> 
                <extrudeGeometry args={[pierShape,{depth: pierL, bevelEnabled:false}]}/> 
                <meshStandardMaterial wireframe={wireframe} color="darkgray"/> 
                {edgesVisible && <Edges color="black"/>} 
              </mesh>
              
              {/* Piles */}
              {pilePos.map(([px,pz],i)=>
                <mesh key={`pile-${idx}-${i}`} position={[px,pileCenterY,pz]}> 
                  <cylinderGeometry args={[pileDia/2,pileDia/2,pileLen,16]}/> 
                  <meshStandardMaterial wireframe={wireframe} color="steelblue" transparent opacity={0.7}/> 
                  {edgesVisible && <Edges color="black"/>} 
                </mesh>
              )}
              
              {/* Columns */}
              {colsPos.map(([cx,cz],i)=>
                <mesh key={`col-${idx}-${i}`} position={[cx,(baseColH+elev)/2,cz]}> 
                  {colShape==='circular'
                    ? <cylinderGeometry args={[colW/2,colW/2,baseColH+elev,16]}/>
                    : <boxGeometry args={[colW,baseColH+elev,colD]}/>
                  } 
                  <meshStandardMaterial wireframe={wireframe} color="tomato"/> 
                  {edgesVisible && <Edges color="black"/>} 
                </mesh>
              )}
            </group>
          ))}

          {/* Render Girders and Deck */}
          {continuousGirders ? (
            // Continuous girders spanning entire bridge
            <>
              {girderPos.map((x, j) => {
                // Create path for continuous girder spanning entire bridge
                const girderPoints: THREE.Vector3[] = [];
                for (let i = 0; i < pierInfos.length - 1; i++) {
                  const spanPoints = createCurvedPoints(pierInfos[i], pierInfos[i+1], 10);

                  if (i === 0) {
                    girderPoints.push(...spanPoints);
                  } else {
                    // Skip first point to avoid duplication
                    girderPoints.push(...spanPoints.slice(1));
                  }
                }
                
                return (
                  <group key={`continuous-girder-${j}`}>
                    {girderPoints.map((point, idx) => {
                      if (idx === girderPoints.length - 1) return null;
                      const nextPoint = girderPoints[idx + 1];
                      const segmentLength = point.distanceTo(nextPoint);
                      
                      // Skip segments that are too small or invalid
                      if (segmentLength < 0.1 || !isFinite(segmentLength)) return null;
                      
                      const midPoint = point.clone().add(nextPoint).multiplyScalar(0.5);
                      const direction = nextPoint.clone().sub(point).normalize();
                      const angle = Math.atan2(direction.x, direction.z);
                      
                      return (
                        <group key={`segment-${idx}`} position={[midPoint.x, midPoint.y + baseColH + pierThk, midPoint.z]} rotation={[0, angle, 0]}>
                          {/* Web */}
                          <mesh position={[x, tfBot + webH/2, 0]}>
                            <boxGeometry args={[Math.max(webT, 2), webH, segmentLength]}/>
                            <meshStandardMaterial wireframe={wireframe} color="saddlebrown" />
                            {edgesVisible && <Edges color="black" />}
                          </mesh>
                          {/* Top Flange */}
                          <mesh position={[x, tfBot + webH + Math.max(tfTop, 2)/2, 0]}>
                            <boxGeometry args={[bfTop, Math.max(tfTop, 2), segmentLength]}/>
                            <meshStandardMaterial wireframe={wireframe} color="peru"/>
                            {edgesVisible && <Edges color="black" />}
                          </mesh>
                          {/* Bottom Flange */}
                          <mesh position={[x, Math.max(tfBot, 2)/2, 0]}>
                            <boxGeometry args={[bfBot, Math.max(tfBot, 2), segmentLength]}/>
                            <meshStandardMaterial wireframe={wireframe} color="peru"/>
                            {edgesVisible && <Edges color="black" />}
                          </mesh>
                          {/* Haunch */}
                          <mesh position={[x, Math.max(tfBot, 2) + webH + Math.max(tfTop, 2) + Math.max(haunchThk, 2)/2, 0]}>
                            <boxGeometry args={[bfTop, Math.max(haunchThk, 2), segmentLength]}/>
                            <meshStandardMaterial wireframe={wireframe} color="#c2b280"/>
                            {edgesVisible && <Edges color="black" />}
                          </mesh>
                        </group>
                      );
                    })}
                  </group>
                );
              })}
              {/* Continuous Deck */}
              {(() => {
                const deckPoints: THREE.Vector3[] = [];
                for (let i = 0; i < pierInfos.length - 1; i++) {
                  const spanPoints = createCurvedPoints(pierInfos[i], pierInfos[i+1], 10);
                  if (i === 0) {
                    deckPoints.push(...spanPoints);
                  } else {
                    // Skip first point to avoid duplication
                    deckPoints.push(...spanPoints.slice(1));
                  }
                }
                
                return deckPoints.map((point, idx) => {
                  if (idx === deckPoints.length - 1) return null;
                  const nextPoint = deckPoints[idx + 1];
                  const segmentLength = point.distanceTo(nextPoint);
                  
                  // Skip segments that are too small or invalid
                  if (segmentLength < 0.1 || !isFinite(segmentLength)) return null;
                  
                  const midPoint = point.clone().add(nextPoint).multiplyScalar(0.5);
                  const direction = nextPoint.clone().sub(point).normalize();
                  const angle = Math.atan2(direction.x, direction.z);
                  
                  return (
                    <mesh key={`deck-segment-${idx}`} 
                          position={[midPoint.x, midPoint.y + baseColH + pierThk + Math.max(tfBot, 2) + webH + Math.max(tfTop, 2) + Math.max(haunchThk, 2) + deckThk/2, midPoint.z]} 
                          rotation={[0, angle, 0]}>
                      <boxGeometry args={[girderSpacing*(girderCount-1) + deckOverhang*2, deckThk, segmentLength]}/>
                      <meshStandardMaterial wireframe={wireframe} color="#c2b280" />
                      {edgesVisible && <Edges color="black" />}
                    </mesh>
                  );
                });
              })()}
            </>
          ) : (
            // Simple span girders with gaps at interior piers
            pierInfos.map((info, i) => {
              if (i === pierInfos.length - 1) return null;
              const start = pierInfos[i];
              const end = pierInfos[i+1];
              
              // Create shortened span points with gaps at piers
              const gapDistance = 12; // 1 foot gap from each end = 2 foot total gap
              const totalDistance = Math.sqrt(
                Math.pow(end.x - start.x, 2) + 
                Math.pow(end.z - start.z, 2)
              );
              
              // Calculate adjusted start and end points with gaps
              const direction = new THREE.Vector3(end.x - start.x, 0, end.z - start.z).normalize();
              const adjustedStart = {
                x: start.x + direction.x * gapDistance,
                z: start.z + direction.z * gapDistance,
                elev: start.elev + (end.elev - start.elev) * (gapDistance / totalDistance),
                rotY: start.rotY
              };
              const adjustedEnd = {
                x: end.x - direction.x * gapDistance,
                z: end.z - direction.z * gapDistance,
                elev: end.elev - (end.elev - start.elev) * (gapDistance / totalDistance),
                rotY: end.rotY
              };
              
              const spanPoints = createCurvedPoints(adjustedStart, adjustedEnd, 20);
              
              return (
                <group key={`span-${i}`}>
                  {/* Girders */}
                  {girderPos.map((x, j) => (
                    <group key={`girder-${j}`}>
                      {spanPoints.map((point, idx) => {
                        if (idx === spanPoints.length - 1) return null;
                        const nextPoint = spanPoints[idx + 1];
                        const segmentLength = point.distanceTo(nextPoint);
                        const midPoint = point.clone().add(nextPoint).multiplyScalar(0.5);
                        const direction = nextPoint.clone().sub(point).normalize();
                        const angle = Math.atan2(direction.x, direction.z);
                        
                        return (
                          <group key={`segment-${idx}`} position={[midPoint.x, midPoint.y + baseColH + pierThk, midPoint.z]} rotation={[0, angle, 0]}>
                            {/* Web */}
                            <mesh position={[x, tfBot + webH/2, 0]}>
                              <boxGeometry args={[webT, webH, segmentLength]}/>
                              <meshStandardMaterial wireframe={wireframe} color="saddlebrown" />
                              {edgesVisible && <Edges color="black" />}
                            </mesh>
                            {/* Top Flange */}
                            <mesh position={[x, tfBot + webH + tfTop/2, 0]}>
                              <boxGeometry args={[bfTop, tfTop, segmentLength]}/>
                              <meshStandardMaterial wireframe={wireframe} color="peru"/>
                              {edgesVisible && <Edges color="black" />}
                            </mesh>
                            {/* Bottom Flange */}
                            <mesh position={[x, tfBot/2, 0]}>
                              <boxGeometry args={[bfBot, tfBot, segmentLength]}/>
                              <meshStandardMaterial wireframe={wireframe} color="peru"/>
                              {edgesVisible && <Edges color="black" />}
                            </mesh>
                            {/* Haunch */}
                            <mesh position={[x, tfBot + webH + tfTop + haunchThk/2, 0]}>
                              <boxGeometry args={[bfTop, haunchThk, segmentLength]}/>
                              <meshStandardMaterial wireframe={wireframe} color="#c2b280"/>
                              {edgesVisible && <Edges color="black" />}
                            </mesh>
                          </group>
                        );
                      })}
                    </group>
                  ))}
                  {/* Deck */}
                  {spanPoints.map((point, idx) => {
                    if (idx === spanPoints.length - 1) return null;
                    const nextPoint = spanPoints[idx + 1];
                    const segmentLength = point.distanceTo(nextPoint);
                    const midPoint = point.clone().add(nextPoint).multiplyScalar(0.5);
                    const direction = nextPoint.clone().sub(point).normalize();
                    const angle = Math.atan2(direction.x, direction.z);
                    
                    return (
                      <mesh key={`deck-segment-${idx}`} 
                            position={[midPoint.x, midPoint.y + baseColH + pierThk + tfBot + webH + tfTop + haunchThk + deckThk/2, midPoint.z]} 
                            rotation={[0, angle, 0]}>
                        <boxGeometry args={[girderSpacing*(girderCount-1) + deckOverhang*2, deckThk, segmentLength]}/>
                        <meshStandardMaterial wireframe={wireframe} color="#c2b280" />
                        {edgesVisible && <Edges color="black" />}
                      </mesh>
                    );
                  })}
                </group>
              );
            })
          )}

          <OrbitControls ref={controlsRef}/>
        </Canvas>
      </main>
    </div>
  );
}

================================================================================================
APP COMPONENT: client/src/App.tsx
================================================================================================

import React from 'react';
import BridgePierGeometryTool from './components/BridgePierGeometryTool';
import "@fontsource/inter";

function App() {
  return <BridgePierGeometryTool />;
}

export default App;

================================================================================================
PROJECT DEPENDENCIES: package.json
================================================================================================

{
  "name": "rest-express",
  "version": "1.0.0",
  "type": "module",
  "license": "MIT",
  "scripts": {
    "dev": "tsx server/index.ts",
    "build": "vite build && esbuild server/index.ts --platform=node --packages=external --bundle --format=esm --outdir=dist",
    "start": "NODE_ENV=production node dist/index.js",
    "check": "tsc",
    "db:push": "drizzle-kit push"
  },
  "dependencies": {
    "@fontsource/inter": "^5.2.5",
    "@jridgewell/trace-mapping": "^0.3.25",
    "@neondatabase/serverless": "^0.10.4",
    "@radix-ui/react-accordion": "^1.2.1",
    "@radix-ui/react-alert-dialog": "^1.1.2",
    "@radix-ui/react-aspect-ratio": "^1.1.0",
    "@radix-ui/react-avatar": "^1.1.1",
    "@radix-ui/react-checkbox": "^1.1.2",
    "@radix-ui/react-collapsible": "^1.1.1",
    "@radix-ui/react-context-menu": "^2.2.2",
    "@radix-ui/react-dialog": "^1.1.2",
    "@radix-ui/react-dropdown-menu": "^2.1.2",
    "@radix-ui/react-hover-card": "^1.1.2",
    "@radix-ui/react-label": "^2.1.0",
    "@radix-ui/react-menubar": "^1.1.2",
    "@radix-ui/react-navigation-menu": "^1.2.1",
    "@radix-ui/react-popover": "^1.1.2",
    "@radix-ui/react-progress": "^1.1.0",
    "@radix-ui/react-radio-group": "^1.2.1",
    "@radix-ui/react-scroll-area": "^1.2.0",
    "@radix-ui/react-select": "^2.1.2",
    "@radix-ui/react-separator": "^1.1.0",
    "@radix-ui/react-slider": "^1.2.1",
    "@radix-ui/react-slot": "^1.1.0",
    "@radix-ui/react-switch": "^1.1.1",
    "@radix-ui/react-tabs": "^1.1.1",
    "@radix-ui/react-toast": "^1.2.2",
    "@radix-ui/react-toggle": "^1.1.0",
    "@radix-ui/react-toggle-group": "^1.1.0",
    "@radix-ui/react-tooltip": "^1.1.3",
    "@react-three/drei": "^9.122.0",
    "@react-three/fiber": "^8.18.0",
    "@react-three/postprocessing": "^2.19.1",
    "@tanstack/react-query": "^5.60.5",
    "class-variance-authority": "^0.7.0",
    "clsx": "^2.1.1",
    "cmdk": "^1.0.0",
    "connect-pg-simple": "^10.0.0",
    "date-fns": "^3.6.0",
    "drizzle-orm": "^0.39.1",
    "drizzle-zod": "^0.7.0",
    "embla-carousel-react": "^8.3.0",
    "express": "^4.21.2",
    "express-session": "^1.18.1",
    "framer-motion": "^11.13.1",
    "gl-matrix": "^3.4.3",
    "gsap": "^3.12.5",
    "howler": "^2.2.4",
    "input-otp": "^1.2.4",
    "lucide-react": "^0.453.0",
    "matter-js": "^0.20.0",
    "memorystore": "^1.6.7",
    "meshline": "^3.3.1",
    "next-themes": "^0.4.5",
    "ogl": "^1.0.11",
    "passport": "^0.7.0",
    "passport-local": "^1.0.0",
    "pixi.js": "^8.8.1",
    "postprocessing": "^6.36.0",
    "r3f-perf": "^7.2.3",
    "react": "^18.3.1",
    "react-confetti": "^6.4.0",
    "react-day-picker": "^8.10.1",
    "react-dom": "^18.3.1",
    "react-haiku": "^2.2.0",
    "react-helmet-async": "^2.0.5",
    "react-hook-form": "^7.53.1",
    "react-icons": "^5.4.0",
    "react-leaflet": "^4.2.1",
    "react-resizable-panels": "^2.1.4",
    "react-router-dom": "^6.26.0",
    "react-syntax-highlighter": "^15.5.0",
    "react-use-gesture": "^9.1.3",
    "react-useanimations": "^2.10.0",
    "recharts": "^2.13.0",
    "sonner": "^1.7.1",
    "tailwind-merge": "^2.5.4",
    "tailwind-scrollbar": "^3.1.0",
    "tailwindcss-animate": "^1.0.7",
    "three": "^0.170.0",
    "vaul": "^1.1.0",
    "vite-plugin-glsl": "^1.3.1",
    "wouter": "^3.3.5",
    "ws": "^8.18.0",
    "zod": "^3.23.8",
    "zod-validation-error": "^3.4.0",
    "zustand": "^5.0.3"
  },
  "devDependencies": {
    "@replit/vite-plugin-runtime-error-modal": "^0.0.3",
    "@tailwindcss/typography": "^0.5.15",
    "@types/connect-pg-simple": "^7.0.3",
    "@types/express": "4.17.21",
    "@types/express-session": "^1.18.0",
    "@types/node": "20.16.11",
    "@types/passport": "^1.0.16",
    "@types/passport-local": "^1.0.38",
    "@types/react": "^18.3.11",
    "@types/react-dom": "^18.3.1",
    "@types/ws": "^8.5.13",
    "@vitejs/plugin-react": "^4.3.2",
    "autoprefixer": "^10.4.20",
    "drizzle-kit": "^0.30.4",
    "esbuild": "^0.25.0",
    "postcss": "^8.4.47",
    "tailwindcss": "^3.4.14",
    "tsx": "^4.19.1",
    "typescript": "5.6.3",
    "vite": "^5.4.19"
  },
  "optionalDependencies": {
    "bufferutil": "^4.0.8"
  }
}

================================================================================================
STYLES: client/src/index.css
================================================================================================

@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 222.2 84% 4.9%;
    --card: 0 0% 100%;
    --card-foreground: 222.2 84% 4.9%;
    --popover: 0 0% 100%;
    --popover-foreground: 222.2 84% 4.9%;
    --primary: 222.2 47.4% 11.2%;
    --primary-foreground: 210 40% 98%;
    --secondary: 210 40% 96%;
    --secondary-foreground: 222.2 84% 4.9%;
    --muted: 210 40% 96%;
    --muted-foreground: 215.4 16.3% 46.9%;
    --accent: 210 40% 96%;
    --accent-foreground: 222.2 84% 4.9%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 210 40% 98%;
    --border: 214.3 31.8% 91.4%;
    --input: 214.3 31.8% 91.4%;
    --ring: 222.2 84% 4.9%;
    --radius: 0.5rem;
    --chart-1: 12 76% 61%;
    --chart-2: 173 58% 39%;
    --chart-3: 197 37% 24%;
    --chart-4: 43 74% 66%;
    --chart-5: 27 87% 67%;
  }

  .dark {
    --background: 222.2 84% 4.9%;
    --foreground: 210 40% 98%;
    --card: 222.2 84% 4.9%;
    --card-foreground: 210 40% 98%;
    --popover: 222.2 84% 4.9%;
    --popover-foreground: 210 40% 98%;
    --primary: 210 40% 98%;
    --primary-foreground: 222.2 47.4% 11.2%;
    --secondary: 217.2 32.6% 17.5%;
    --secondary-foreground: 210 40% 98%;
    --muted: 217.2 32.6% 17.5%;
    --muted-foreground: 215 20.2% 65.1%;
    --accent: 217.2 32.6% 17.5%;
    --accent-foreground: 210 40% 98%;
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 210 40% 98%;
    --border: 217.2 32.6% 17.5%;
    --input: 217.2 32.6% 17.5%;
    --ring: 212.7 26.8% 83.9%;
    --chart-1: 220 70% 50%;
    --chart-2: 160 60% 45%;
    --chart-3: 30 80% 55%;
    --chart-4: 280 65% 60%;
    --chart-5: 340 75% 55%;
  }

  * {
    @apply border-border;
  }

  body {
    @apply font-sans antialiased bg-background text-foreground;
    margin: 0;
    padding: 0;
    width: 100vw;
    height: 100vh;
    overflow: hidden;
  }
}

#root {
  width: 100%;
  height: 100%;
  position: fixed;
}

canvas {
  width: 100% !important;
  height: 100% !important;
  touch-action: none;
}

/* Print styles */
@media print {
  .flex {
    display: block !important;
  }
  aside {
    display: none !important;
  }
  main {
    width: 100% !important;
    height: 100vh !important;
  }
  canvas {
    width: 100% !important;
    height: 100% !important;
  }
}

================================================================================================
BUILD CONFIGURATION: vite.config.ts
================================================================================================

import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
import path, { dirname } from "path";
import runtimeErrorOverlay from "@replit/vite-plugin-runtime-error-modal";
import { fileURLToPath } from "url";
import glsl from "vite-plugin-glsl";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

export default defineConfig({
  plugins: [
    react(),
    runtimeErrorOverlay(),
    glsl(), // Add GLSL shader support
  ],
  resolve: {
    alias: {
      "@": path.resolve(__dirname, "client", "src"),
      "@shared": path.resolve(__dirname, "shared"),
    },
  },
  root: path.resolve(__dirname, "client"),
  build: {
    outDir: path.resolve(__dirname, "dist/public"),
    emptyOutDir: true,
  },
  // Add support for large models and audio files
  assetsInclude: ["**/*.gltf", "**/*.glb", "**/*.mp3", "**/*.ogg", "**/*.wav"],
});

================================================================================================
PROJECT DOCUMENTATION: replit.md
================================================================================================

# Bridge Pier Geometry Tool

## Overview

This is a sophisticated 3D bridge pier geometry design tool built for civil engineering applications. It combines a modern React frontend with Express.js backend, featuring interactive 3D visualization using Three.js for designing and visualizing bridge pier components including piles, columns, pier caps, girders, deck structures, and haunch geometry.

**Status**: Early version complete - fully functional with comprehensive bridge design capabilities including curved alignments, continuous/simple span options, and detailed quantity takeoffs.

## Recent Changes

**January 27, 2025**: Implemented haunch geometry between girders and deck
- Added user-definable haunch thickness parameter with minimum thickness control
- Implemented haunch 3D visualization for both continuous and simple span configurations
- Updated deck positioning to properly account for haunch thickness
- Enhanced quantity calculations to include haunch concrete volume in takeoffs
- Fixed haunch and deck elevation positioning relative to girder top flange
- Haunch color matches deck color for visual consistency

**Earlier**: Fixed critical issue with curved geometry rendering for continuous girders
- Resolved superstructure disappearing when "Use Curve" and "Continuous Girders Over Piers" were both enabled
- Added fallback logic for pier reference lookup in curve calculations
- Ensured minimum thickness values for girder components to maintain visibility
- All curved and straight configurations now render correctly with both continuous and simple span options

## User Preferences

Preferred communication style: Simple, everyday language.

## System Architecture

The application follows a full-stack TypeScript architecture with clear separation between client and server:

### Frontend Architecture
- **Framework**: React 18 with TypeScript
- **3D Rendering**: Three.js with React Three Fiber (@react-three/fiber)
- **UI Components**: Radix UI components with custom styling
- **Styling**: Tailwind CSS with custom design system
- **State Management**: Zustand for game/application state and audio management
- **Build Tool**: Vite for fast development and optimized builds

### Backend Architecture
- **Runtime**: Node.js with Express.js
- **Language**: TypeScript with ES modules
- **Database ORM**: Drizzle ORM
- **Database**: PostgreSQL (configured for Neon Database)
- **Session Management**: PostgreSQL-backed sessions
- **Development**: Hot reload with tsx

## Key Components

### 3D Visualization Engine
- **Three.js Integration**: Canvas-based 3D rendering with orbital controls
- **Camera Systems**: Both orthographic and perspective camera support
- **Geometry Generation**: Procedural generation of bridge components
- **Real-time Updates**: Live parameter adjustments with immediate visual feedback

### Bridge Design Components
- **Pile Foundation System**: Configurable pile layouts, diameters, and lengths
- **Column Structure**: Multiple column shapes (rectangular/circular) with spacing controls
- **Pier Cap Design**: Tapered pier caps with customizable dimensions
- **Girder Systems**: Built-up plate girders with flange and web specifications
- **Deck Geometry**: Bridge deck with overhang configurations

### User Interface
- **Parameter Controls**: Extensive form controls for all geometric parameters
- **Unit System**: Imperial units (inches/feet) for US engineering standards
- **Real-time Preview**: Instant 3D model updates as parameters change
- **Professional Design**: Clean, engineering-focused interface

### Audio System
- **State Management**: Zustand-based audio state with mute controls
- **Sound Effects**: Hit and success sound management
- **Background Music**: Optional background audio support

## Data Flow

1. **User Input**: Parameter changes through UI controls
2. **State Update**: React state management updates geometry parameters
3. **Geometry Calculation**: Mathematical computation of 3D coordinates
4. **3D Rendering**: Three.js renders updated geometry in real-time
5. **Visual Feedback**: Immediate display of design changes

### Database Schema
- **Users Table**: Basic user authentication structure
- **Session Management**: PostgreSQL-backed session storage
- **Future Extensions**: Schema ready for design storage and sharing

## External Dependencies

### Core Technologies
- **@neondatabase/serverless**: PostgreSQL database connectivity
- **@react-three/drei**: Three.js helpers and controls
- **@react-three/fiber**: React Three.js integration
- **@radix-ui/***: Comprehensive UI component library
- **drizzle-orm**: Type-safe database ORM
- **tailwindcss**: Utility-first CSS framework

### Development Tools
- **tsx**: TypeScript execution for development
- **esbuild**: Fast JavaScript bundler for production
- **vite**: Development server and build tool
- **typescript**: Static type checking

### Engineering Libraries
- **class-variance-authority**: Type-safe CSS class variants
- **cmdk**: Command palette functionality
- **date-fns**: Date manipulation utilities

## Deployment Strategy

### Development Environment
- **Local Development**: Vite dev server with hot reload
- **Database**: Environment variable-based PostgreSQL connection
- **Build Process**: Separate client and server build pipelines

### Production Build
- **Frontend**: Vite builds optimized static assets
- **Backend**: esbuild bundles Node.js server
- **Database Migrations**: Drizzle Kit handles schema migrations
- **Environment**: Production mode with optimized performance

### Database Configuration
- **Migration System**: Drizzle Kit for schema management
- **Connection**: Environment variable-based DATABASE_URL
- **Session Storage**: PostgreSQL-backed session management
- **Schema Location**: Shared schema definitions in `/shared` directory

### Asset Management
- **3D Assets**: Support for GLTF/GLB model files
- **Audio Assets**: MP3/OGG/WAV audio file support
- **Font Assets**: Inter font family integration
- **Static Assets**: Optimized asset pipeline through Vite

The application is designed for professional civil engineering use, providing accurate 3D visualization of bridge pier geometry with real-time parameter adjustment capabilities.
================================================================================================
END OF CODE PACKAGE
================================================================================================
